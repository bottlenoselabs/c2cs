
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/bottlenoselabs/c2cs (v0.0.0.0)
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
#nullable enable
#pragma warning disable 1591
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs.clang.Runtime;

namespace bottlenoselabs
{
    public static unsafe partial class clang
    {
        private const string LibraryName = "clang";

        // Function @ CXString.h:50:28 (clang-c\CXString.h)
        [DllImport(LibraryName)]
        public static extern CString clang_getCString(CXString @string);

        // Function @ Index.h:266:24 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);

        // Function @ Index.h:358:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXString clang_getFileName(CXFile SFile);

        // Function @ Index.h:507:20 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern int clang_Location_isInSystemHeader(CXSourceLocation location);

        // Function @ Index.h:674:21 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern void clang_getFileLocation(CXSourceLocation location, CXFile* file, ulong* line, ulong* column, ulong* offset);

        // Function @ Index.h:861:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_getNumDiagnostics(CXTranslationUnit Unit);

        // Function @ Index.h:872:29 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, uint Index);

        // Function @ Index.h:972:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, uint Options);

        // Function @ Index.h:982:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_defaultDiagnosticDisplayOptions();

        // Function @ Index.h:988:5 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic param);

        // Function @ Index.h:1418:33 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXErrorCode clang_parseTranslationUnit2(CXIndex CIdx, CString source_filename, CString* command_line_args, int num_command_line_args, CXUnsavedFile* unsaved_files, uint num_unsaved_files, uint options, CXTranslationUnit* out_TU);

        // Function @ Index.h:2705:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXCursor clang_getTranslationUnitCursor(CXTranslationUnit param);

        // Function @ Index.h:2725:34 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXCursorKind clang_getCursorKind(CXCursor param);

        // Function @ Index.h:2820:35 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXLinkageKind clang_getCursorLinkage(CXCursor cursor);

        // Function @ Index.h:2993:34 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor param);

        // Function @ Index.h:3198:33 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXSourceLocation clang_getCursorLocation(CXCursor param);

        // Function @ Index.h:3211:30 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXSourceRange clang_getCursorExtent(CXCursor param);

        // Function @ Index.h:3414:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getCursorType(CXCursor C);

        // Function @ Index.h:3422:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXString clang_getTypeSpelling(CXType CT);

        // Function @ Index.h:3430:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getTypedefDeclUnderlyingType(CXCursor C);

        // Function @ Index.h:3438:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getEnumDeclIntegerType(CXCursor C);

        // Function @ Index.h:3448:26 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern long clang_getEnumConstantDeclValue(CXCursor C);

        // Function @ Index.h:3633:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_Cursor_isMacroFunctionLike(CXCursor C);

        // Function @ Index.h:3639:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_Cursor_isMacroBuiltin(CXCursor C);

        // Function @ Index.h:3674:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getPointeeType(CXType T);

        // Function @ Index.h:3679:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXCursor clang_getTypeDeclaration(CXType T);

        // Function @ Index.h:3701:35 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXCallingConv clang_getFunctionTypeCallingConv(CXType T);

        // Function @ Index.h:3708:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getResultType(CXType T);

        // Function @ Index.h:3781:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getCursorResultType(CXCursor C);

        // Function @ Index.h:3804:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getElementType(CXType T);

        // Function @ Index.h:3819:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_getArrayElementType(CXType T);

        // Function @ Index.h:3826:26 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern long clang_getArraySize(CXType T);

        // Function @ Index.h:3833:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_Type_getNamedType(CXType T);

        // Function @ Index.h:3927:26 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern long clang_Type_getAlignOf(CXType T);

        // Function @ Index.h:3945:26 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern long clang_Type_getSizeOf(CXType T);

        // Function @ Index.h:3967:23 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXType clang_Type_getModifiedType(CXType T);

        // Function @ Index.h:3989:26 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern long clang_Cursor_getOffsetOfField(CXCursor C);

        // Function @ Index.h:3995:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_Cursor_isAnonymous(CXCursor C);

        // Function @ Index.h:4217:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern uint clang_visitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data);

        // Function @ Index.h:4312:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXString clang_getCursorSpelling(CXCursor param);

        // Function @ Index.h:5001:25 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern CXString clang_getTokenSpelling(CXTranslationUnit param, CXToken param2);

        // Function @ Index.h:5031:21 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken** Tokens, ulong* NumTokens);

        // Function @ Index.h:5070:21 (clang-c\Index.h)
        [DllImport(LibraryName)]
        public static extern void clang_disposeTokens(CXTranslationUnit TU, CXToken* Tokens, uint NumTokens);

        // FunctionPointer @ Index.h:4191:35 (clang-c\Index.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct CXCursorVisitor
        {
            public delegate* unmanaged<CXCursor, CXCursor, CXClientData, CXChildVisitResult> Pointer;
        }

        // Struct @ CXString.h:40:3 (clang-c\CXString.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct CXString
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* data;

            [FieldOffset(8)] // size = 4, padding = 4
            public uint private_flags;
        }

        // Struct @ Index.h:459:3 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct CXSourceLocation
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public fixed ulong _ptr_data[16 / 8]; // void*[2]

            public Span<nint> ptr_data
            {
                get
                {
                    fixed (CXSourceLocation* @this = &this)
                    {
                        var pointer = &@this->_ptr_data[0];
                        var span = new Span<nint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(16)] // size = 4, padding = 4
            public uint int_data;
        }

        // Struct @ Index.h:101:8 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct CXUnsavedFile
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CString Filename;

            [FieldOffset(8)] // size = 8, padding = 0
            public CString Contents;

            [FieldOffset(16)] // size = 4, padding = 4
            public uint Length;
        }

        // Struct @ Index.h:2686:3 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct CXCursor
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public CXCursorKind kind;

            [FieldOffset(4)] // size = 4, padding = 0
            public int xdata;

            [FieldOffset(8)] // size = 24, padding = 0
            public fixed ulong _data[24 / 8]; // void*[3]

            public Span<nint> data
            {
                get
                {
                    fixed (CXCursor* @this = &this)
                    {
                        var pointer = &@this->_data[0];
                        var span = new Span<nint>(pointer, 3);
                        return span;
                    }
                }
            }
        }

        // Struct @ Index.h:471:3 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct CXSourceRange
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public fixed ulong _ptr_data[16 / 8]; // void*[2]

            public Span<nint> ptr_data
            {
                get
                {
                    fixed (CXSourceRange* @this = &this)
                    {
                        var pointer = &@this->_ptr_data[0];
                        var span = new Span<nint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(16)] // size = 4, padding = 0
            public uint begin_int_data;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint end_int_data;
        }

        // Struct @ Index.h:3409:3 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct CXType
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public CXTypeKind kind;

            [FieldOffset(8)] // size = 16, padding = 0
            public fixed ulong _data[16 / 8]; // void*[2]

            public Span<nint> data
            {
                get
                {
                    fixed (CXType* @this = &this)
                    {
                        var pointer = &@this->_data[0];
                        var span = new Span<nint>(pointer, 2);
                        return span;
                    }
                }
            }
        }

        // Struct @ Index.h:4974:3 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct CXToken
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public fixed uint _int_data[16 / 4]; // unsigned int[4]

            public Span<uint> int_data
            {
                get
                {
                    fixed (CXToken* @this = &this)
                    {
                        var pointer = &@this->_int_data[0];
                        var span = new Span<uint>(pointer, 4);
                        return span;
                    }
                }
            }

            [FieldOffset(16)] // size = 8, padding = 0
            public void* ptr_data;
        }

        // OpaqueType @ Index.h:86:16 (clang-c\Index.h)
        [StructLayout(LayoutKind.Sequential)]
        public struct CXTranslationUnitImpl
        {
        }

        // Typedef @ Index.h:75:15 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct CXIndex
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* Data;

            public static implicit operator void*(CXIndex data) => data.Data;
            public static implicit operator CXIndex(void* data) => new() { Data = data };
        }

        // Typedef @ Index.h:353:15 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct CXFile
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* Data;

            public static implicit operator void*(CXFile data) => data.Data;
            public static implicit operator CXFile(void* data) => new() { Data = data };
        }

        // Typedef @ Index.h:86:39 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct CXTranslationUnit
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CXTranslationUnitImpl* Data;

            public static implicit operator CXTranslationUnitImpl*(CXTranslationUnit data) => data.Data;
            public static implicit operator CXTranslationUnit(CXTranslationUnitImpl* data) => new() { Data = data };
        }

        // Typedef @ Index.h:775:15 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct CXDiagnostic
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* Data;

            public static implicit operator void*(CXDiagnostic data) => data.Data;
            public static implicit operator CXDiagnostic(void* data) => new() { Data = data };
        }

        // Typedef @ Index.h:92:15 (clang-c\Index.h)
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct CXClientData
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* Data;

            public static implicit operator void*(CXClientData data) => data.Data;
            public static implicit operator CXClientData(void* data) => new() { Data = data };
        }

        // Enum @ Index.h:739:6 (clang-c\Index.h)
        public enum CXDiagnosticSeverity : int
        {
            CXDiagnostic_Ignored = 0,
            CXDiagnostic_Note = 1,
            CXDiagnostic_Warning = 2,
            CXDiagnostic_Error = 3,
            CXDiagnostic_Fatal = 4
        }

        // Enum @ CXErrorCode.h:28:6 (clang-c\CXErrorCode.h)
        public enum CXErrorCode : int
        {
            CXError_Success = 0,
            CXError_Failure = 1,
            CXError_Crashed = 2,
            CXError_InvalidArguments = 3,
            CXError_ASTReadError = 4
        }

        // Enum @ Index.h:1706:6 (clang-c\Index.h)
        public enum CXCursorKind : int
        {
            CXCursor_UnexposedDecl = 1,
            CXCursor_StructDecl = 2,
            CXCursor_UnionDecl = 3,
            CXCursor_ClassDecl = 4,
            CXCursor_EnumDecl = 5,
            CXCursor_FieldDecl = 6,
            CXCursor_EnumConstantDecl = 7,
            CXCursor_FunctionDecl = 8,
            CXCursor_VarDecl = 9,
            CXCursor_ParmDecl = 10,
            CXCursor_ObjCInterfaceDecl = 11,
            CXCursor_ObjCCategoryDecl = 12,
            CXCursor_ObjCProtocolDecl = 13,
            CXCursor_ObjCPropertyDecl = 14,
            CXCursor_ObjCIvarDecl = 15,
            CXCursor_ObjCInstanceMethodDecl = 16,
            CXCursor_ObjCClassMethodDecl = 17,
            CXCursor_ObjCImplementationDecl = 18,
            CXCursor_ObjCCategoryImplDecl = 19,
            CXCursor_TypedefDecl = 20,
            CXCursor_CXXMethod = 21,
            CXCursor_Namespace = 22,
            CXCursor_LinkageSpec = 23,
            CXCursor_Constructor = 24,
            CXCursor_Destructor = 25,
            CXCursor_ConversionFunction = 26,
            CXCursor_TemplateTypeParameter = 27,
            CXCursor_NonTypeTemplateParameter = 28,
            CXCursor_TemplateTemplateParameter = 29,
            CXCursor_FunctionTemplate = 30,
            CXCursor_ClassTemplate = 31,
            CXCursor_ClassTemplatePartialSpecialization = 32,
            CXCursor_NamespaceAlias = 33,
            CXCursor_UsingDirective = 34,
            CXCursor_UsingDeclaration = 35,
            CXCursor_TypeAliasDecl = 36,
            CXCursor_ObjCSynthesizeDecl = 37,
            CXCursor_ObjCDynamicDecl = 38,
            CXCursor_CXXAccessSpecifier = 39,
            CXCursor_FirstDecl = 1,
            CXCursor_LastDecl = 39,
            CXCursor_FirstRef = 40,
            CXCursor_ObjCSuperClassRef = 40,
            CXCursor_ObjCProtocolRef = 41,
            CXCursor_ObjCClassRef = 42,
            CXCursor_TypeRef = 43,
            CXCursor_CXXBaseSpecifier = 44,
            CXCursor_TemplateRef = 45,
            CXCursor_NamespaceRef = 46,
            CXCursor_MemberRef = 47,
            CXCursor_LabelRef = 48,
            CXCursor_OverloadedDeclRef = 49,
            CXCursor_VariableRef = 50,
            CXCursor_LastRef = 50,
            CXCursor_FirstInvalid = 70,
            CXCursor_InvalidFile = 70,
            CXCursor_NoDeclFound = 71,
            CXCursor_NotImplemented = 72,
            CXCursor_InvalidCode = 73,
            CXCursor_LastInvalid = 73,
            CXCursor_FirstExpr = 100,
            CXCursor_UnexposedExpr = 100,
            CXCursor_DeclRefExpr = 101,
            CXCursor_MemberRefExpr = 102,
            CXCursor_CallExpr = 103,
            CXCursor_ObjCMessageExpr = 104,
            CXCursor_BlockExpr = 105,
            CXCursor_IntegerLiteral = 106,
            CXCursor_FloatingLiteral = 107,
            CXCursor_ImaginaryLiteral = 108,
            CXCursor_StringLiteral = 109,
            CXCursor_CharacterLiteral = 110,
            CXCursor_ParenExpr = 111,
            CXCursor_UnaryOperator = 112,
            CXCursor_ArraySubscriptExpr = 113,
            CXCursor_BinaryOperator = 114,
            CXCursor_CompoundAssignOperator = 115,
            CXCursor_ConditionalOperator = 116,
            CXCursor_CStyleCastExpr = 117,
            CXCursor_CompoundLiteralExpr = 118,
            CXCursor_InitListExpr = 119,
            CXCursor_AddrLabelExpr = 120,
            CXCursor_StmtExpr = 121,
            CXCursor_GenericSelectionExpr = 122,
            CXCursor_GNUNullExpr = 123,
            CXCursor_CXXStaticCastExpr = 124,
            CXCursor_CXXDynamicCastExpr = 125,
            CXCursor_CXXReinterpretCastExpr = 126,
            CXCursor_CXXConstCastExpr = 127,
            CXCursor_CXXFunctionalCastExpr = 128,
            CXCursor_CXXTypeidExpr = 129,
            CXCursor_CXXBoolLiteralExpr = 130,
            CXCursor_CXXNullPtrLiteralExpr = 131,
            CXCursor_CXXThisExpr = 132,
            CXCursor_CXXThrowExpr = 133,
            CXCursor_CXXNewExpr = 134,
            CXCursor_CXXDeleteExpr = 135,
            CXCursor_UnaryExpr = 136,
            CXCursor_ObjCStringLiteral = 137,
            CXCursor_ObjCEncodeExpr = 138,
            CXCursor_ObjCSelectorExpr = 139,
            CXCursor_ObjCProtocolExpr = 140,
            CXCursor_ObjCBridgedCastExpr = 141,
            CXCursor_PackExpansionExpr = 142,
            CXCursor_SizeOfPackExpr = 143,
            CXCursor_LambdaExpr = 144,
            CXCursor_ObjCBoolLiteralExpr = 145,
            CXCursor_ObjCSelfExpr = 146,
            CXCursor_OMPArraySectionExpr = 147,
            CXCursor_ObjCAvailabilityCheckExpr = 148,
            CXCursor_FixedPointLiteral = 149,
            CXCursor_OMPArrayShapingExpr = 150,
            CXCursor_OMPIteratorExpr = 151,
            CXCursor_CXXAddrspaceCastExpr = 152,
            CXCursor_LastExpr = 152,
            CXCursor_FirstStmt = 200,
            CXCursor_UnexposedStmt = 200,
            CXCursor_LabelStmt = 201,
            CXCursor_CompoundStmt = 202,
            CXCursor_CaseStmt = 203,
            CXCursor_DefaultStmt = 204,
            CXCursor_IfStmt = 205,
            CXCursor_SwitchStmt = 206,
            CXCursor_WhileStmt = 207,
            CXCursor_DoStmt = 208,
            CXCursor_ForStmt = 209,
            CXCursor_GotoStmt = 210,
            CXCursor_IndirectGotoStmt = 211,
            CXCursor_ContinueStmt = 212,
            CXCursor_BreakStmt = 213,
            CXCursor_ReturnStmt = 214,
            CXCursor_GCCAsmStmt = 215,
            CXCursor_AsmStmt = 215,
            CXCursor_ObjCAtTryStmt = 216,
            CXCursor_ObjCAtCatchStmt = 217,
            CXCursor_ObjCAtFinallyStmt = 218,
            CXCursor_ObjCAtThrowStmt = 219,
            CXCursor_ObjCAtSynchronizedStmt = 220,
            CXCursor_ObjCAutoreleasePoolStmt = 221,
            CXCursor_ObjCForCollectionStmt = 222,
            CXCursor_CXXCatchStmt = 223,
            CXCursor_CXXTryStmt = 224,
            CXCursor_CXXForRangeStmt = 225,
            CXCursor_SEHTryStmt = 226,
            CXCursor_SEHExceptStmt = 227,
            CXCursor_SEHFinallyStmt = 228,
            CXCursor_MSAsmStmt = 229,
            CXCursor_NullStmt = 230,
            CXCursor_DeclStmt = 231,
            CXCursor_OMPParallelDirective = 232,
            CXCursor_OMPSimdDirective = 233,
            CXCursor_OMPForDirective = 234,
            CXCursor_OMPSectionsDirective = 235,
            CXCursor_OMPSectionDirective = 236,
            CXCursor_OMPSingleDirective = 237,
            CXCursor_OMPParallelForDirective = 238,
            CXCursor_OMPParallelSectionsDirective = 239,
            CXCursor_OMPTaskDirective = 240,
            CXCursor_OMPMasterDirective = 241,
            CXCursor_OMPCriticalDirective = 242,
            CXCursor_OMPTaskyieldDirective = 243,
            CXCursor_OMPBarrierDirective = 244,
            CXCursor_OMPTaskwaitDirective = 245,
            CXCursor_OMPFlushDirective = 246,
            CXCursor_SEHLeaveStmt = 247,
            CXCursor_OMPOrderedDirective = 248,
            CXCursor_OMPAtomicDirective = 249,
            CXCursor_OMPForSimdDirective = 250,
            CXCursor_OMPParallelForSimdDirective = 251,
            CXCursor_OMPTargetDirective = 252,
            CXCursor_OMPTeamsDirective = 253,
            CXCursor_OMPTaskgroupDirective = 254,
            CXCursor_OMPCancellationPointDirective = 255,
            CXCursor_OMPCancelDirective = 256,
            CXCursor_OMPTargetDataDirective = 257,
            CXCursor_OMPTaskLoopDirective = 258,
            CXCursor_OMPTaskLoopSimdDirective = 259,
            CXCursor_OMPDistributeDirective = 260,
            CXCursor_OMPTargetEnterDataDirective = 261,
            CXCursor_OMPTargetExitDataDirective = 262,
            CXCursor_OMPTargetParallelDirective = 263,
            CXCursor_OMPTargetParallelForDirective = 264,
            CXCursor_OMPTargetUpdateDirective = 265,
            CXCursor_OMPDistributeParallelForDirective = 266,
            CXCursor_OMPDistributeParallelForSimdDirective = 267,
            CXCursor_OMPDistributeSimdDirective = 268,
            CXCursor_OMPTargetParallelForSimdDirective = 269,
            CXCursor_OMPTargetSimdDirective = 270,
            CXCursor_OMPTeamsDistributeDirective = 271,
            CXCursor_OMPTeamsDistributeSimdDirective = 272,
            CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273,
            CXCursor_OMPTeamsDistributeParallelForDirective = 274,
            CXCursor_OMPTargetTeamsDirective = 275,
            CXCursor_OMPTargetTeamsDistributeDirective = 276,
            CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277,
            CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278,
            CXCursor_OMPTargetTeamsDistributeSimdDirective = 279,
            CXCursor_BuiltinBitCastExpr = 280,
            CXCursor_OMPMasterTaskLoopDirective = 281,
            CXCursor_OMPParallelMasterTaskLoopDirective = 282,
            CXCursor_OMPMasterTaskLoopSimdDirective = 283,
            CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284,
            CXCursor_OMPParallelMasterDirective = 285,
            CXCursor_OMPDepobjDirective = 286,
            CXCursor_OMPScanDirective = 287,
            CXCursor_LastStmt = 287,
            CXCursor_TranslationUnit = 300,
            CXCursor_FirstAttr = 400,
            CXCursor_UnexposedAttr = 400,
            CXCursor_IBActionAttr = 401,
            CXCursor_IBOutletAttr = 402,
            CXCursor_IBOutletCollectionAttr = 403,
            CXCursor_CXXFinalAttr = 404,
            CXCursor_CXXOverrideAttr = 405,
            CXCursor_AnnotateAttr = 406,
            CXCursor_AsmLabelAttr = 407,
            CXCursor_PackedAttr = 408,
            CXCursor_PureAttr = 409,
            CXCursor_ConstAttr = 410,
            CXCursor_NoDuplicateAttr = 411,
            CXCursor_CUDAConstantAttr = 412,
            CXCursor_CUDADeviceAttr = 413,
            CXCursor_CUDAGlobalAttr = 414,
            CXCursor_CUDAHostAttr = 415,
            CXCursor_CUDASharedAttr = 416,
            CXCursor_VisibilityAttr = 417,
            CXCursor_DLLExport = 418,
            CXCursor_DLLImport = 419,
            CXCursor_NSReturnsRetained = 420,
            CXCursor_NSReturnsNotRetained = 421,
            CXCursor_NSReturnsAutoreleased = 422,
            CXCursor_NSConsumesSelf = 423,
            CXCursor_NSConsumed = 424,
            CXCursor_ObjCException = 425,
            CXCursor_ObjCNSObject = 426,
            CXCursor_ObjCIndependentClass = 427,
            CXCursor_ObjCPreciseLifetime = 428,
            CXCursor_ObjCReturnsInnerPointer = 429,
            CXCursor_ObjCRequiresSuper = 430,
            CXCursor_ObjCRootClass = 431,
            CXCursor_ObjCSubclassingRestricted = 432,
            CXCursor_ObjCExplicitProtocolImpl = 433,
            CXCursor_ObjCDesignatedInitializer = 434,
            CXCursor_ObjCRuntimeVisible = 435,
            CXCursor_ObjCBoxable = 436,
            CXCursor_FlagEnum = 437,
            CXCursor_ConvergentAttr = 438,
            CXCursor_WarnUnusedAttr = 439,
            CXCursor_WarnUnusedResultAttr = 440,
            CXCursor_AlignedAttr = 441,
            CXCursor_LastAttr = 441,
            CXCursor_PreprocessingDirective = 500,
            CXCursor_MacroDefinition = 501,
            CXCursor_MacroExpansion = 502,
            CXCursor_MacroInstantiation = 502,
            CXCursor_InclusionDirective = 503,
            CXCursor_FirstPreprocessing = 500,
            CXCursor_LastPreprocessing = 503,
            CXCursor_ModuleImportDecl = 600,
            CXCursor_TypeAliasTemplateDecl = 601,
            CXCursor_StaticAssert = 602,
            CXCursor_FriendDecl = 603,
            CXCursor_FirstExtraDecl = 600,
            CXCursor_LastExtraDecl = 603,
            CXCursor_OverloadCandidate = 700
        }

        // Enum @ Index.h:2799:6 (clang-c\Index.h)
        public enum CXLinkageKind : int
        {
            CXLinkage_Invalid = 0,
            CXLinkage_NoLinkage = 1,
            CXLinkage_Internal = 2,
            CXLinkage_UniqueExternal = 3,
            CXLinkage_External = 4
        }

        // Enum @ Index.h:3377:6 (clang-c\Index.h)
        public enum CXCallingConv : int
        {
            CXCallingConv_Default = 0,
            CXCallingConv_C = 1,
            CXCallingConv_X86StdCall = 2,
            CXCallingConv_X86FastCall = 3,
            CXCallingConv_X86ThisCall = 4,
            CXCallingConv_X86Pascal = 5,
            CXCallingConv_AAPCS = 6,
            CXCallingConv_AAPCS_VFP = 7,
            CXCallingConv_X86RegCall = 8,
            CXCallingConv_IntelOclBicc = 9,
            CXCallingConv_Win64 = 10,
            CXCallingConv_X86_64Win64 = 10,
            CXCallingConv_X86_64SysV = 11,
            CXCallingConv_X86VectorCall = 12,
            CXCallingConv_Swift = 13,
            CXCallingConv_PreserveMost = 14,
            CXCallingConv_PreserveAll = 15,
            CXCallingConv_AArch64VectorCall = 16,
            CXCallingConv_Invalid = 100,
            CXCallingConv_Unexposed = 200
        }

        // Enum @ Index.h:3226:6 (clang-c\Index.h)
        public enum CXTypeKind : int
        {
            CXType_Invalid = 0,
            CXType_Unexposed = 1,
            CXType_Void = 2,
            CXType_Bool = 3,
            CXType_Char_U = 4,
            CXType_UChar = 5,
            CXType_Char16 = 6,
            CXType_Char32 = 7,
            CXType_UShort = 8,
            CXType_UInt = 9,
            CXType_ULong = 10,
            CXType_ULongLong = 11,
            CXType_UInt128 = 12,
            CXType_Char_S = 13,
            CXType_SChar = 14,
            CXType_WChar = 15,
            CXType_Short = 16,
            CXType_Int = 17,
            CXType_Long = 18,
            CXType_LongLong = 19,
            CXType_Int128 = 20,
            CXType_Float = 21,
            CXType_Double = 22,
            CXType_LongDouble = 23,
            CXType_NullPtr = 24,
            CXType_Overload = 25,
            CXType_Dependent = 26,
            CXType_ObjCId = 27,
            CXType_ObjCClass = 28,
            CXType_ObjCSel = 29,
            CXType_Float128 = 30,
            CXType_Half = 31,
            CXType_Float16 = 32,
            CXType_ShortAccum = 33,
            CXType_Accum = 34,
            CXType_LongAccum = 35,
            CXType_UShortAccum = 36,
            CXType_UAccum = 37,
            CXType_ULongAccum = 38,
            CXType_BFloat16 = 39,
            CXType_FirstBuiltin = 2,
            CXType_LastBuiltin = 39,
            CXType_Complex = 100,
            CXType_Pointer = 101,
            CXType_BlockPointer = 102,
            CXType_LValueReference = 103,
            CXType_RValueReference = 104,
            CXType_Record = 105,
            CXType_Enum = 106,
            CXType_Typedef = 107,
            CXType_ObjCInterface = 108,
            CXType_ObjCObjectPointer = 109,
            CXType_FunctionNoProto = 110,
            CXType_FunctionProto = 111,
            CXType_ConstantArray = 112,
            CXType_Vector = 113,
            CXType_IncompleteArray = 114,
            CXType_VariableArray = 115,
            CXType_DependentSizedArray = 116,
            CXType_MemberPointer = 117,
            CXType_Auto = 118,
            CXType_Elaborated = 119,
            CXType_Pipe = 120,
            CXType_OCLImage1dRO = 121,
            CXType_OCLImage1dArrayRO = 122,
            CXType_OCLImage1dBufferRO = 123,
            CXType_OCLImage2dRO = 124,
            CXType_OCLImage2dArrayRO = 125,
            CXType_OCLImage2dDepthRO = 126,
            CXType_OCLImage2dArrayDepthRO = 127,
            CXType_OCLImage2dMSAARO = 128,
            CXType_OCLImage2dArrayMSAARO = 129,
            CXType_OCLImage2dMSAADepthRO = 130,
            CXType_OCLImage2dArrayMSAADepthRO = 131,
            CXType_OCLImage3dRO = 132,
            CXType_OCLImage1dWO = 133,
            CXType_OCLImage1dArrayWO = 134,
            CXType_OCLImage1dBufferWO = 135,
            CXType_OCLImage2dWO = 136,
            CXType_OCLImage2dArrayWO = 137,
            CXType_OCLImage2dDepthWO = 138,
            CXType_OCLImage2dArrayDepthWO = 139,
            CXType_OCLImage2dMSAAWO = 140,
            CXType_OCLImage2dArrayMSAAWO = 141,
            CXType_OCLImage2dMSAADepthWO = 142,
            CXType_OCLImage2dArrayMSAADepthWO = 143,
            CXType_OCLImage3dWO = 144,
            CXType_OCLImage1dRW = 145,
            CXType_OCLImage1dArrayRW = 146,
            CXType_OCLImage1dBufferRW = 147,
            CXType_OCLImage2dRW = 148,
            CXType_OCLImage2dArrayRW = 149,
            CXType_OCLImage2dDepthRW = 150,
            CXType_OCLImage2dArrayDepthRW = 151,
            CXType_OCLImage2dMSAARW = 152,
            CXType_OCLImage2dArrayMSAARW = 153,
            CXType_OCLImage2dMSAADepthRW = 154,
            CXType_OCLImage2dArrayMSAADepthRW = 155,
            CXType_OCLImage3dRW = 156,
            CXType_OCLSampler = 157,
            CXType_OCLEvent = 158,
            CXType_OCLQueue = 159,
            CXType_OCLReserveID = 160,
            CXType_ObjCObject = 161,
            CXType_ObjCTypeParam = 162,
            CXType_Attributed = 163,
            CXType_OCLIntelSubgroupAVCMcePayload = 164,
            CXType_OCLIntelSubgroupAVCImePayload = 165,
            CXType_OCLIntelSubgroupAVCRefPayload = 166,
            CXType_OCLIntelSubgroupAVCSicPayload = 167,
            CXType_OCLIntelSubgroupAVCMceResult = 168,
            CXType_OCLIntelSubgroupAVCImeResult = 169,
            CXType_OCLIntelSubgroupAVCRefResult = 170,
            CXType_OCLIntelSubgroupAVCSicResult = 171,
            CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,
            CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,
            CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174,
            CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175,
            CXType_ExtVector = 176,
            CXType_Atomic = 177
        }

        // Enum @ Index.h:4162:6 (clang-c\Index.h)
        public enum CXChildVisitResult : int
        {
            CXChildVisit_Break = 0,
            CXChildVisit_Continue = 1,
            CXChildVisit_Recurse = 2
        }

        // Pseudo enum 'CXAvailabilityKind' @ Index.h:125:6 (clang-c\Index.h)
        public const int CXAvailability_Available = 0;
        public const int CXAvailability_Deprecated = 1;
        public const int CXAvailability_NotAvailable = 2;
        public const int CXAvailability_NotAccessible = 3;

        // Pseudo enum 'CXCursor_ExceptionSpecificationKind' @ Index.h:174:6 (clang-c\Index.h)
        public const int CXCursor_ExceptionSpecificationKind_None = 0;
        public const int CXCursor_ExceptionSpecificationKind_DynamicNone = 1;
        public const int CXCursor_ExceptionSpecificationKind_Dynamic = 2;
        public const int CXCursor_ExceptionSpecificationKind_MSAny = 3;
        public const int CXCursor_ExceptionSpecificationKind_BasicNoexcept = 4;
        public const int CXCursor_ExceptionSpecificationKind_ComputedNoexcept = 5;
        public const int CXCursor_ExceptionSpecificationKind_Unevaluated = 6;
        public const int CXCursor_ExceptionSpecificationKind_Uninstantiated = 7;
        public const int CXCursor_ExceptionSpecificationKind_Unparsed = 8;
        public const int CXCursor_ExceptionSpecificationKind_NoThrow = 9;

        // Pseudo enum 'CXGlobalOptFlags' @ Index.h:277:9 (clang-c\Index.h)
        public const int CXGlobalOpt_None = 0;
        public const int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 1;
        public const int CXGlobalOpt_ThreadBackgroundPriorityForEditing = 2;
        public const int CXGlobalOpt_ThreadBackgroundPriorityForAll = 3;

        // Pseudo enum 'CXLoadDiag_Error' @ Index.h:803:6 (clang-c\Index.h)
        public const int CXLoadDiag_None = 0;
        public const int CXLoadDiag_Unknown = 1;
        public const int CXLoadDiag_CannotLoad = 2;
        public const int CXLoadDiag_InvalidFile = 3;

        // Pseudo enum 'CXDiagnosticDisplayOptions' @ Index.h:895:6 (clang-c\Index.h)
        public const int CXDiagnostic_DisplaySourceLocation = 1;
        public const int CXDiagnostic_DisplayColumn = 2;
        public const int CXDiagnostic_DisplaySourceRanges = 4;
        public const int CXDiagnostic_DisplayOption = 8;
        public const int CXDiagnostic_DisplayCategoryId = 16;
        public const int CXDiagnostic_DisplayCategoryName = 32;

        // Pseudo enum 'CXTranslationUnit_Flags' @ Index.h:1199:6 (clang-c\Index.h)
        public const int CXTranslationUnit_None = 0;
        public const int CXTranslationUnit_DetailedPreprocessingRecord = 1;
        public const int CXTranslationUnit_Incomplete = 2;
        public const int CXTranslationUnit_PrecompiledPreamble = 4;
        public const int CXTranslationUnit_CacheCompletionResults = 8;
        public const int CXTranslationUnit_ForSerialization = 16;
        public const int CXTranslationUnit_CXXChainedPCH = 32;
        public const int CXTranslationUnit_SkipFunctionBodies = 64;
        public const int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 128;
        public const int CXTranslationUnit_CreatePreambleOnFirstParse = 256;
        public const int CXTranslationUnit_KeepGoing = 512;
        public const int CXTranslationUnit_SingleFileParse = 1024;
        public const int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 2048;
        public const int CXTranslationUnit_IncludeAttributedTypes = 4096;
        public const int CXTranslationUnit_VisitImplicitAttributes = 8192;
        public const int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 16384;
        public const int CXTranslationUnit_RetainExcludedConditionalBlocks = 32768;

        // Pseudo enum 'CXSaveTranslationUnit_Flags' @ Index.h:1442:6 (clang-c\Index.h)
        public const int CXSaveTranslationUnit_None = 0;

        // Pseudo enum 'CXSaveError' @ Index.h:1464:6 (clang-c\Index.h)
        public const int CXSaveError_None = 0;
        public const int CXSaveError_Unknown = 1;
        public const int CXSaveError_TranslationErrors = 2;
        public const int CXSaveError_InvalidTU = 3;

        // Pseudo enum 'CXReparse_Flags' @ Index.h:1543:6 (clang-c\Index.h)
        public const int CXReparse_None = 0;

        // Pseudo enum 'CXTUResourceUsageKind' @ Index.h:1609:6 (clang-c\Index.h)
        public const int CXTUResourceUsage_AST = 1;
        public const int CXTUResourceUsage_Identifiers = 2;
        public const int CXTUResourceUsage_Selectors = 3;
        public const int CXTUResourceUsage_GlobalCompletionResults = 4;
        public const int CXTUResourceUsage_SourceManagerContentCache = 5;
        public const int CXTUResourceUsage_AST_SideTables = 6;
        public const int CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7;
        public const int CXTUResourceUsage_SourceManager_Membuffer_MMap = 8;
        public const int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9;
        public const int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10;
        public const int CXTUResourceUsage_Preprocessor = 11;
        public const int CXTUResourceUsage_PreprocessingRecord = 12;
        public const int CXTUResourceUsage_SourceManager_DataStructures = 13;
        public const int CXTUResourceUsage_Preprocessor_HeaderSearch = 14;
        public const int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = 1;
        public const int CXTUResourceUsage_MEMORY_IN_BYTES_END = 14;
        public const int CXTUResourceUsage_First = 1;
        public const int CXTUResourceUsage_Last = 14;

        // Pseudo enum 'CXVisibilityKind' @ Index.h:2822:6 (clang-c\Index.h)
        public const int CXVisibility_Invalid = 0;
        public const int CXVisibility_Hidden = 1;
        public const int CXVisibility_Protected = 2;
        public const int CXVisibility_Default = 3;

        // Pseudo enum 'CXLanguageKind' @ Index.h:2966:6 (clang-c\Index.h)
        public const int CXLanguage_Invalid = 0;
        public const int CXLanguage_C = 1;
        public const int CXLanguage_ObjC = 2;
        public const int CXLanguage_CPlusPlus = 3;

        // Pseudo enum 'CXTLSKind' @ Index.h:2982:6 (clang-c\Index.h)
        public const int CXTLS_None = 0;
        public const int CXTLS_Dynamic = 1;
        public const int CXTLS_Static = 2;

        // Pseudo enum 'CXTemplateArgumentKind' @ Index.h:3492:6 (clang-c\Index.h)
        public const int CXTemplateArgumentKind_Null = 0;
        public const int CXTemplateArgumentKind_Type = 1;
        public const int CXTemplateArgumentKind_Declaration = 2;
        public const int CXTemplateArgumentKind_NullPtr = 3;
        public const int CXTemplateArgumentKind_Integral = 4;
        public const int CXTemplateArgumentKind_Template = 5;
        public const int CXTemplateArgumentKind_TemplateExpansion = 6;
        public const int CXTemplateArgumentKind_Expression = 7;
        public const int CXTemplateArgumentKind_Pack = 8;
        public const int CXTemplateArgumentKind_Invalid = 9;

        // Pseudo enum 'CXTypeNullabilityKind' @ Index.h:3845:6 (clang-c\Index.h)
        public const int CXTypeNullability_NonNull = 0;
        public const int CXTypeNullability_Nullable = 1;
        public const int CXTypeNullability_Unspecified = 2;
        public const int CXTypeNullability_Invalid = 3;
        public const int CXTypeNullability_NullableResult = 4;

        // Pseudo enum 'CXTypeLayoutError' @ Index.h:3888:6 (clang-c\Index.h)
        public const int CXTypeLayoutError_Invalid = -1;
        public const int CXTypeLayoutError_Incomplete = -2;
        public const int CXTypeLayoutError_Dependent = -3;
        public const int CXTypeLayoutError_NotConstantSize = -4;
        public const int CXTypeLayoutError_InvalidFieldName = -5;
        public const int CXTypeLayoutError_Undeduced = -6;

        // Pseudo enum 'CXRefQualifierKind' @ Index.h:4009:6 (clang-c\Index.h)
        public const int CXRefQualifier_None = 0;
        public const int CXRefQualifier_LValue = 1;
        public const int CXRefQualifier_RValue = 2;

        // Pseudo enum 'CX_CXXAccessSpecifier' @ Index.h:4058:6 (clang-c\Index.h)
        public const int CX_CXXInvalidAccessSpecifier = 0;
        public const int CX_CXXPublic = 1;
        public const int CX_CXXProtected = 2;
        public const int CX_CXXPrivate = 3;

        // Pseudo enum 'CX_StorageClass' @ Index.h:4078:6 (clang-c\Index.h)
        public const int CX_SC_Invalid = 0;
        public const int CX_SC_None = 1;
        public const int CX_SC_Extern = 2;
        public const int CX_SC_Static = 3;
        public const int CX_SC_PrivateExtern = 4;
        public const int CX_SC_OpenCLWorkGroupLocal = 5;
        public const int CX_SC_Auto = 6;
        public const int CX_SC_Register = 7;

        // Pseudo enum 'CXPrintingPolicyProperty' @ Index.h:4339:6 (clang-c\Index.h)
        public const int CXPrintingPolicy_Indentation = 0;
        public const int CXPrintingPolicy_SuppressSpecifiers = 1;
        public const int CXPrintingPolicy_SuppressTagKeyword = 2;
        public const int CXPrintingPolicy_IncludeTagDefinition = 3;
        public const int CXPrintingPolicy_SuppressScope = 4;
        public const int CXPrintingPolicy_SuppressUnwrittenScope = 5;
        public const int CXPrintingPolicy_SuppressInitializers = 6;
        public const int CXPrintingPolicy_ConstantArraySizeAsWritten = 7;
        public const int CXPrintingPolicy_AnonymousTagLocations = 8;
        public const int CXPrintingPolicy_SuppressStrongLifetime = 9;
        public const int CXPrintingPolicy_SuppressLifetimeQualifiers = 10;
        public const int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = 11;
        public const int CXPrintingPolicy_Bool = 12;
        public const int CXPrintingPolicy_Restrict = 13;
        public const int CXPrintingPolicy_Alignof = 14;
        public const int CXPrintingPolicy_UnderscoreAlignof = 15;
        public const int CXPrintingPolicy_UseVoidForZeroParams = 16;
        public const int CXPrintingPolicy_TerseOutput = 17;
        public const int CXPrintingPolicy_PolishForDeclaration = 18;
        public const int CXPrintingPolicy_Half = 19;
        public const int CXPrintingPolicy_MSWChar = 20;
        public const int CXPrintingPolicy_IncludeNewlines = 21;
        public const int CXPrintingPolicy_MSVCFormatting = 22;
        public const int CXPrintingPolicy_ConstantsAsWritten = 23;
        public const int CXPrintingPolicy_SuppressImplicitBase = 24;
        public const int CXPrintingPolicy_FullyQualifiedName = 25;
        public const int CXPrintingPolicy_LastProperty = 25;

        // Pseudo enum 'CXObjCPropertyAttrKind' @ Index.h:4530:9 (clang-c\Index.h)
        public const int CXObjCPropertyAttr_noattr = 0;
        public const int CXObjCPropertyAttr_readonly = 1;
        public const int CXObjCPropertyAttr_getter = 2;
        public const int CXObjCPropertyAttr_assign = 4;
        public const int CXObjCPropertyAttr_readwrite = 8;
        public const int CXObjCPropertyAttr_retain = 16;
        public const int CXObjCPropertyAttr_copy = 32;
        public const int CXObjCPropertyAttr_nonatomic = 64;
        public const int CXObjCPropertyAttr_setter = 128;
        public const int CXObjCPropertyAttr_atomic = 256;
        public const int CXObjCPropertyAttr_weak = 512;
        public const int CXObjCPropertyAttr_strong = 1024;
        public const int CXObjCPropertyAttr_unsafe_unretained = 2048;
        public const int CXObjCPropertyAttr_class = 4096;

        // Pseudo enum 'CXObjCDeclQualifierKind' @ Index.h:4573:9 (clang-c\Index.h)
        public const int CXObjCDeclQualifier_None = 0;
        public const int CXObjCDeclQualifier_In = 1;
        public const int CXObjCDeclQualifier_Inout = 2;
        public const int CXObjCDeclQualifier_Out = 4;
        public const int CXObjCDeclQualifier_Bycopy = 8;
        public const int CXObjCDeclQualifier_Byref = 16;
        public const int CXObjCDeclQualifier_Oneway = 32;

        // Pseudo enum 'CXNameRefFlags' @ Index.h:4898:6 (clang-c\Index.h)
        public const int CXNameRange_WantQualifier = 1;
        public const int CXNameRange_WantTemplateArgs = 2;
        public const int CXNameRange_WantSinglePiece = 4;

        // Pseudo enum 'CXTokenKind' @ Index.h:4941:14 (clang-c\Index.h)
        public const int CXToken_Punctuation = 0;
        public const int CXToken_Keyword = 1;
        public const int CXToken_Identifier = 2;
        public const int CXToken_Literal = 3;
        public const int CXToken_Comment = 4;

        // Pseudo enum 'CXCompletionChunkKind' @ Index.h:5156:6 (clang-c\Index.h)
        public const int CXCompletionChunk_Optional = 0;
        public const int CXCompletionChunk_TypedText = 1;
        public const int CXCompletionChunk_Text = 2;
        public const int CXCompletionChunk_Placeholder = 3;
        public const int CXCompletionChunk_Informative = 4;
        public const int CXCompletionChunk_CurrentParameter = 5;
        public const int CXCompletionChunk_LeftParen = 6;
        public const int CXCompletionChunk_RightParen = 7;
        public const int CXCompletionChunk_LeftBracket = 8;
        public const int CXCompletionChunk_RightBracket = 9;
        public const int CXCompletionChunk_LeftBrace = 10;
        public const int CXCompletionChunk_RightBrace = 11;
        public const int CXCompletionChunk_LeftAngle = 12;
        public const int CXCompletionChunk_RightAngle = 13;
        public const int CXCompletionChunk_Comma = 14;
        public const int CXCompletionChunk_ResultType = 15;
        public const int CXCompletionChunk_Colon = 16;
        public const int CXCompletionChunk_SemiColon = 17;
        public const int CXCompletionChunk_Equal = 18;
        public const int CXCompletionChunk_HorizontalSpace = 19;
        public const int CXCompletionChunk_VerticalSpace = 20;

        // Pseudo enum 'CXCodeComplete_Flags' @ Index.h:5547:6 (clang-c\Index.h)
        public const int CXCodeComplete_IncludeMacros = 1;
        public const int CXCodeComplete_IncludeCodePatterns = 2;
        public const int CXCodeComplete_IncludeBriefComments = 4;
        public const int CXCodeComplete_SkipPreamble = 8;
        public const int CXCodeComplete_IncludeCompletionsWithFixIts = 16;

        // Pseudo enum 'CXCompletionContext' @ Index.h:5586:6 (clang-c\Index.h)
        public const int CXCompletionContext_Unexposed = 0;
        public const int CXCompletionContext_AnyType = 1;
        public const int CXCompletionContext_AnyValue = 2;
        public const int CXCompletionContext_ObjCObjectValue = 4;
        public const int CXCompletionContext_ObjCSelectorValue = 8;
        public const int CXCompletionContext_CXXClassTypeValue = 16;
        public const int CXCompletionContext_DotMemberAccess = 32;
        public const int CXCompletionContext_ArrowMemberAccess = 64;
        public const int CXCompletionContext_ObjCPropertyAccess = 128;
        public const int CXCompletionContext_EnumTag = 256;
        public const int CXCompletionContext_UnionTag = 512;
        public const int CXCompletionContext_StructTag = 1024;
        public const int CXCompletionContext_ClassTag = 2048;
        public const int CXCompletionContext_Namespace = 4096;
        public const int CXCompletionContext_NestedNameSpecifier = 8192;
        public const int CXCompletionContext_ObjCInterface = 16384;
        public const int CXCompletionContext_ObjCProtocol = 32768;
        public const int CXCompletionContext_ObjCCategory = 65536;
        public const int CXCompletionContext_ObjCInstanceMessage = 131072;
        public const int CXCompletionContext_ObjCClassMessage = 262144;
        public const int CXCompletionContext_ObjCSelectorName = 524288;
        public const int CXCompletionContext_MacroName = 1048576;
        public const int CXCompletionContext_NaturalLanguage = 2097152;
        public const int CXCompletionContext_IncludedFile = 4194304;
        public const int CXCompletionContext_Unknown = 8388607;

        // Pseudo enum 'CXEvalResultKind' @ Index.h:5944:9 (clang-c\Index.h)
        public const int CXEval_Int = 1;
        public const int CXEval_Float = 2;
        public const int CXEval_ObjCStrLiteral = 3;
        public const int CXEval_StrLiteral = 4;
        public const int CXEval_CFStr = 5;
        public const int CXEval_Other = 6;
        public const int CXEval_UnExposed = 0;

        // Pseudo enum 'CXVisitorResult' @ Index.h:6087:6 (clang-c\Index.h)
        public const int CXVisit_Break = 0;
        public const int CXVisit_Continue = 1;

        // Pseudo enum 'CXResult' @ Index.h:6094:9 (clang-c\Index.h)
        public const int CXResult_Success = 0;
        public const int CXResult_Invalid = 1;
        public const int CXResult_VisitBreak = 2;

        // Pseudo enum 'CXIdxEntityKind' @ Index.h:6239:9 (clang-c\Index.h)
        public const int CXIdxEntity_Unexposed = 0;
        public const int CXIdxEntity_Typedef = 1;
        public const int CXIdxEntity_Function = 2;
        public const int CXIdxEntity_Variable = 3;
        public const int CXIdxEntity_Field = 4;
        public const int CXIdxEntity_EnumConstant = 5;
        public const int CXIdxEntity_ObjCClass = 6;
        public const int CXIdxEntity_ObjCProtocol = 7;
        public const int CXIdxEntity_ObjCCategory = 8;
        public const int CXIdxEntity_ObjCInstanceMethod = 9;
        public const int CXIdxEntity_ObjCClassMethod = 10;
        public const int CXIdxEntity_ObjCProperty = 11;
        public const int CXIdxEntity_ObjCIvar = 12;
        public const int CXIdxEntity_Enum = 13;
        public const int CXIdxEntity_Struct = 14;
        public const int CXIdxEntity_Union = 15;
        public const int CXIdxEntity_CXXClass = 16;
        public const int CXIdxEntity_CXXNamespace = 17;
        public const int CXIdxEntity_CXXNamespaceAlias = 18;
        public const int CXIdxEntity_CXXStaticVariable = 19;
        public const int CXIdxEntity_CXXStaticMethod = 20;
        public const int CXIdxEntity_CXXInstanceMethod = 21;
        public const int CXIdxEntity_CXXConstructor = 22;
        public const int CXIdxEntity_CXXDestructor = 23;
        public const int CXIdxEntity_CXXConversionFunction = 24;
        public const int CXIdxEntity_CXXTypeAlias = 25;
        public const int CXIdxEntity_CXXInterface = 26;

        // Pseudo enum 'CXIdxEntityLanguage' @ Index.h:6274:9 (clang-c\Index.h)
        public const int CXIdxEntityLang_None = 0;
        public const int CXIdxEntityLang_C = 1;
        public const int CXIdxEntityLang_ObjC = 2;
        public const int CXIdxEntityLang_CXX = 3;
        public const int CXIdxEntityLang_Swift = 4;

        // Pseudo enum 'CXIdxEntityCXXTemplateKind' @ Index.h:6292:9 (clang-c\Index.h)
        public const int CXIdxEntity_NonTemplate = 0;
        public const int CXIdxEntity_Template = 1;
        public const int CXIdxEntity_TemplatePartialSpecialization = 2;
        public const int CXIdxEntity_TemplateSpecialization = 3;

        // Pseudo enum 'CXIdxAttrKind' @ Index.h:6299:9 (clang-c\Index.h)
        public const int CXIdxAttr_Unexposed = 0;
        public const int CXIdxAttr_IBAction = 1;
        public const int CXIdxAttr_IBOutlet = 2;
        public const int CXIdxAttr_IBOutletCollection = 3;

        // Pseudo enum 'CXIdxDeclInfoFlags' @ Index.h:6334:9 (clang-c\Index.h)
        public const int CXIdxDeclFlag_Skipped = 1;

        // Pseudo enum 'CXIdxObjCContainerKind' @ Index.h:6362:9 (clang-c\Index.h)
        public const int CXIdxObjCContainer_ForwardRef = 0;
        public const int CXIdxObjCContainer_Interface = 1;
        public const int CXIdxObjCContainer_Implementation = 2;

        // Pseudo enum 'CXIdxEntityRefKind' @ Index.h:6422:9 (clang-c\Index.h)
        public const int CXIdxEntityRef_Direct = 1;
        public const int CXIdxEntityRef_Implicit = 2;

        // Pseudo enum 'CXSymbolRole' @ Index.h:6440:9 (clang-c\Index.h)
        public const int CXSymbolRole_None = 0;
        public const int CXSymbolRole_Declaration = 1;
        public const int CXSymbolRole_Definition = 2;
        public const int CXSymbolRole_Reference = 4;
        public const int CXSymbolRole_Read = 8;
        public const int CXSymbolRole_Write = 16;
        public const int CXSymbolRole_Call = 32;
        public const int CXSymbolRole_Dynamic = 64;
        public const int CXSymbolRole_AddressOf = 128;
        public const int CXSymbolRole_Implicit = 256;

        // Pseudo enum 'CXIndexOptFlags' @ Index.h:6612:9 (clang-c\Index.h)
        public const int CXIndexOpt_None = 0;
        public const int CXIndexOpt_SuppressRedundantRefs = 1;
        public const int CXIndexOpt_IndexFunctionLocalSymbols = 2;
        public const int CXIndexOpt_IndexImplicitTemplateInstantiations = 4;
        public const int CXIndexOpt_SuppressWarnings = 8;
        public const int CXIndexOpt_SkipParsedBodiesInSession = 16;

        // MacroDefinition @ Index.h:35:9 (clang-c\Index.h)
        public const int CINDEX_VERSION_MAJOR = 0;

        // MacroDefinition @ Index.h:36:9 (clang-c\Index.h)
        public const int CINDEX_VERSION_MINOR = 61;

        #region C2CS.Runtime

        public static class Runtime
        {

            /// <summary>
            ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
            ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
            ///     <c>true</c>.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CBool : IEquatable<CBool>
            {
                private readonly byte _value;

                private CBool(bool value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static implicit operator CBool(bool value)
                {
                    return FromBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static CBool FromBoolean(bool value)
                {
                    return new CBool(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static implicit operator bool(CBool value)
                {
                    return ToBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static bool ToBoolean(CBool value)
                {
                    return Convert.ToBoolean(value._value);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return ToBoolean(this).ToString();
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CBool b && Equals(b);
                }

                /// <inheritdoc />
                public bool Equals(CBool other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CBool left, CBool right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CBool left, CBool right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CBool left, CBool right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
            ///     an unmanaged context.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
            {
                private readonly byte _value;

                private CChar(byte value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static implicit operator CChar(byte value)
                {
                    return FromByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static CChar FromByte(byte value)
                {
                    return new CChar(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static implicit operator byte(CChar value)
                {
                    return ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static byte ToByte(CChar value)
                {
                    return value._value;
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CChar value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(byte other)
                {
                    return _value == other;
                }

                /// <inheritdoc />
                public bool Equals(CChar other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CChar left, CChar right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CChar left, CChar right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CChar left, CChar right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the memory layout of a <c>wchar_t</c> in an unmanaged context. The memory layout in a
            ///     managed context depends on the operating system or otherwise on preprocessor directives defines.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CCharWide : IEquatable<CCharWide>
            {
#if SIZEOF_WCHAR_T_1
    private readonly byte _value;
#elif SIZEOF_WCHAR_T_2
    private readonly ushort _value;
#elif SIZEOF_WCHAR_T_4
    private readonly uint _value;
#else
                private readonly ushort _value;
#endif

                private CCharWide(byte value)
                {
#if SIZEOF_WCHAR_T_1
        _value = Convert.ToByte(value);
#elif SIZEOF_WCHAR_T_2
        _value = Convert.ToUInt16(value);
#elif SIZEOF_WCHAR_T_4
        _value = Convert.ToUInt32(value);
#else
                    _value = Convert.ToUInt16(value);
#endif
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CCharWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CCharWide other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CCharWide left, CCharWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A pointer value type of bytes that represent a string; the C type `char*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CString : IEquatable<CString>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CString(string s)
                {
                    _pointer = CStrings.CString(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static explicit operator CString(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromIntPtr(nint value)
                {
                    return new CString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString From(byte* value)
                {
                    return new CString((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CString value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CString value)
                {
                    return CStrings.String(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromString(string s)
                {
                    return CStrings.CString(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.String(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CString value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CString other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CString left, CString right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }
            }

            /// <summary>
            ///     The collection of utility methods for interoperability with C style strings in C#.
            /// </summary>
            public static unsafe class CStrings
            {
                private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
                private static readonly Dictionary<nint, string> PointersToStrings = new();
                private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
                private static readonly Dictionary<nint, string> PointersToStringsWide = new();

                /// <summary>
                ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string String(CString value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStrings.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStrings[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringAnsi(value._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointers.Add(hash, value);
                    PointersToStrings.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string StringWide(CStringWide value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStringsWide[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringUni(pointer2._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointersWide.Add(hash, value);
                    PointersToStringsWide.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
                ///     <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CString CString(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointers.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalAnsi(str);
                    StringHashesToPointers.Add(hash, new CString(pointer));
                    PointersToStrings.Add(pointer, str);

                    return new CString(pointer);
                }

                /// <summary>
                ///     Converts a C string pointer (one dimensional byte array terminated by a
                ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CStringWide CStringWide(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalUni(str);
                    StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
                    PointersToStringsWide.Add(pointer, str);

                    return new CStringWide(pointer);
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
                ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CString* CStringArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CString(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
                ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CStringWide(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
                ///     objects which happened during <see cref="String" />, <see cref="StringWide" />, <see cref="CString" />
                ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
                /// </summary>
                public static void FreeAllStrings()
                {
                    foreach (var (ptr, _) in PointersToStrings)
                    {
                        Marshal.FreeHGlobal(ptr);
                    }

                    // We can not guarantee that the application has not a strong reference the string since it was allocated,
                    //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
                    //  on the responsibility of the application developer. The best we can do is just remove any and all strong
                    //  references we have here to the strings.

                    StringHashesToPointers.Clear();
                    PointersToStrings.Clear();
                }

                /// <summary>
                ///     Frees the memory for specific previously allocated C strings and releases associated references to
                ///     <see cref="string" /> objects which happened during <see cref="String" /> or
                ///     <see cref="CString" />. Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="pointers">The C string pointers.</param>
                /// <param name="count">The number of C string pointers.</param>
                public static void FreeCStrings(CString* pointers, int count)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var ptr = pointers[i];
                        FreeCString(ptr);
                    }

                    Marshal.FreeHGlobal((IntPtr)pointers);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCString(CString value)
                {
                    if (!PointersToStrings.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointers.Remove(hash);
                    PointersToStrings.Remove(value._pointer);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCStringWide(CStringWide value)
                {
                    if (!PointersToStringsWide.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointersWide.Remove(hash);
                    PointersToStringsWide.Remove(value._pointer);
                }

                // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
                //  References:
                //  (1) https://stackoverflow.com/a/7666577/2171957
                //  (2) http://www.cse.yorku.ca/~oz/hash.html
                //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
                private static uint Djb2(byte* str)
                {
                    uint hash = 5381;

                    unchecked
                    {
                        uint c;
                        while ((c = *str++) != 0)
                        {
                            hash = (hash << 5) + hash + c; // hash * 33 + c
                        }
                    }

                    return hash;
                }

                private static uint Djb2(string str)
                {
                    uint hash = 5381;

                    // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
                    foreach (var c in str)
                    {
                        hash = (hash << 5) + hash + c; // hash * 33 + c
                    }

                    return hash;
                }
            }

            /// <summary>
            ///     A pointer value type that represents a wide string; C type `wchar_t*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CStringWide : IEquatable<CStringWide>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CStringWide(string s)
                {
                    _pointer = CStrings.CStringWide(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static explicit operator CStringWide(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromIntPtr(nint value)
                {
                    return new CStringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide From(byte* value)
                {
                    return new CStringWide((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CStringWide value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CStringWide value)
                {
                    return CStrings.StringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromString(string s)
                {
                    return CStrings.CStringWide(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.StringWide(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CStringWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CStringWide other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CStringWide left, CStringWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }
            }
        }

        #endregion
    }
}

