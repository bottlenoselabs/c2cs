// <auto-generated>
//  This code was generated by the following tool on 2023-05-07 19:35:42 GMT-04:00:
//      https://github.com/bottlenoselabs/c2cs (v2.11.1.99)
//
//  Changes to this file may cause incorrect behavior and will be lost if the code is
//      regenerated. To extend or add functionality use a partial class in a new file.
// </auto-generated>
// ReSharper disable All

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS8981
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs._container_library.Runtime;

[assembly: DefaultDllImportSearchPathsAttribute(DllImportSearchPath.SafeDirectories)]
#if NET7_0_OR_GREATER
[assembly: DisableRuntimeMarshalling]
#endif

namespace bottlenoselabs;

public static unsafe partial class _container_library
{
    private const string LibraryName = "_container_library";

    #region API

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt16__print_EnumForceSInt16", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceSInt16__print_EnumForceSInt16(EnumForceSInt16 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt16__return_EnumForceSInt16", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceSInt16 EnumForceSInt16__return_EnumForceSInt16(EnumForceSInt16 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt32__print_EnumForceSInt32", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceSInt32__print_EnumForceSInt32(EnumForceSInt32 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt32__return_EnumForceSInt32", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceSInt32 EnumForceSInt32__return_EnumForceSInt32(EnumForceSInt32 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt64__print_EnumForceSInt64", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceSInt64__print_EnumForceSInt64(EnumForceSInt64 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt64__return_EnumForceSInt64", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceSInt64 EnumForceSInt64__return_EnumForceSInt64(EnumForceSInt64 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt8__print_EnumForceSInt8", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceSInt8__print_EnumForceSInt8(EnumForceSInt8 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceSInt8__return_EnumForceSInt8", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceSInt8 EnumForceSInt8__return_EnumForceSInt8(EnumForceSInt8 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt16__print_EnumForceUInt16", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceUInt16__print_EnumForceUInt16(EnumForceUInt16 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt16__return_EnumForceUInt16", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceUInt16 EnumForceUInt16__return_EnumForceUInt16(EnumForceUInt16 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt32__print_EnumForceUInt32", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceUInt32__print_EnumForceUInt32(EnumForceUInt32 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt32__return_EnumForceUInt32", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceUInt32 EnumForceUInt32__return_EnumForceUInt32(EnumForceUInt32 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt64__print_EnumForceUInt64", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceUInt64__print_EnumForceUInt64(EnumForceUInt64 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt64__return_EnumForceUInt64", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceUInt64 EnumForceUInt64__return_EnumForceUInt64(EnumForceUInt64 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt8__print_EnumForceUInt8", CallingConvention = CallingConvention.Cdecl)]
    public static extern void EnumForceUInt8__print_EnumForceUInt8(EnumForceUInt8 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "EnumForceUInt8__return_EnumForceUInt8", CallingConvention = CallingConvention.Cdecl)]
    public static extern EnumForceUInt8 EnumForceUInt8__return_EnumForceUInt8(EnumForceUInt8 e);

    [CNode(Kind = "Function")]
    [DllImport(LibraryName, EntryPoint = "TypeDef_FunctionPointer_ReturnVoid_ArgsVoid__invoke", CallingConvention = CallingConvention.Cdecl)]
    public static extern void TypeDef_FunctionPointer_ReturnVoid_ArgsVoid__invoke(TypeDef_FunctionPointer_ReturnVoid_ArgsVoid functionPointer);

    #endregion

    #region Types

    [CNode(Kind = "FunctionPointer")]
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_Void
    {
        public delegate* unmanaged<void> Pointer;
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceSInt16 : int
    {
        ENUM_FORCE_SINT16_DAY_UNKNOWN = 0,
        ENUM_FORCE_SINT16_DAY_MONDAY = 1,
        ENUM_FORCE_SINT16_DAY_TUESDAY = 2,
        ENUM_FORCE_SINT16_DAY_WEDNESDAY = 3,
        ENUM_FORCE_SINT16_DAY_THURSDAY = 4,
        ENUM_FORCE_SINT16_DAY_FRIDAY = 5,
        _ENUM_FORCE_SINT16 = 32767
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceSInt32 : int
    {
        ENUM_FORCE_SINT32_DAY_UNKNOWN = 0,
        ENUM_FORCE_SINT32_DAY_MONDAY = 1,
        ENUM_FORCE_SINT32_DAY_TUESDAY = 2,
        ENUM_FORCE_SINT32_DAY_WEDNESDAY = 3,
        ENUM_FORCE_SINT32_DAY_THURSDAY = 4,
        ENUM_FORCE_SINT32_DAY_FRIDAY = 5,
        _ENUM_FORCE_SINT32 = 8388607
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceSInt64 : int
    {
        ENUM_FORCE_SINT64_DAY_UNKNOWN = 0,
        ENUM_FORCE_SINT64_DAY_MONDAY = 1,
        ENUM_FORCE_SINT64_DAY_TUESDAY = 2,
        ENUM_FORCE_SINT64_DAY_WEDNESDAY = 3,
        ENUM_FORCE_SINT64_DAY_THURSDAY = 4,
        ENUM_FORCE_SINT64_DAY_FRIDAY = 5,
        _ENUM_FORCE_SINT64 = 2147483647
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceSInt8 : int
    {
        ENUM_FORCE_SINT8_DAY_UNKNOWN = 0,
        ENUM_FORCE_SINT8_DAY_MONDAY = 1,
        ENUM_FORCE_SINT8_DAY_TUESDAY = 2,
        ENUM_FORCE_SINT8_DAY_WEDNESDAY = 3,
        ENUM_FORCE_SINT8_DAY_THURSDAY = 4,
        ENUM_FORCE_SINT8_DAY_FRIDAY = 5,
        _ENUM_FORCE_SINT8 = 127
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceUInt16 : int
    {
        ENUM_FORCE_UINT16_DAY_UNKNOWN = 0,
        ENUM_FORCE_UINT16_DAY_MONDAY = 1,
        ENUM_FORCE_UINT16_DAY_TUESDAY = 2,
        ENUM_FORCE_UINT16_DAY_WEDNESDAY = 3,
        ENUM_FORCE_UINT16_DAY_THURSDAY = 4,
        ENUM_FORCE_UINT16_DAY_FRIDAY = 5,
        _ENUM_FORCE_UINT16 = 65535
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceUInt32 : long
    {
        ENUM_FORCE_UINT32_DAY_UNKNOWN = 0L,
        ENUM_FORCE_UINT32_DAY_MONDAY = 1L,
        ENUM_FORCE_UINT32_DAY_TUESDAY = 2L,
        ENUM_FORCE_UINT32_DAY_WEDNESDAY = 3L,
        ENUM_FORCE_UINT32_DAY_THURSDAY = 4L,
        ENUM_FORCE_UINT32_DAY_FRIDAY = 5L,
        _ENUM_FORCE_UINT32 = -1L
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceUInt64 : int
    {
        ENUM_FORCE_UINT64_DAY_UNKNOWN = 0,
        ENUM_FORCE_UINT64_DAY_MONDAY = 1,
        ENUM_FORCE_UINT64_DAY_TUESDAY = 2,
        ENUM_FORCE_UINT64_DAY_WEDNESDAY = 3,
        ENUM_FORCE_UINT64_DAY_THURSDAY = 4,
        ENUM_FORCE_UINT64_DAY_FRIDAY = 5,
        _ENUM_FORCE_UINT64 = -1
    }

    [CNode(Kind = "Enum")]
    public enum EnumForceUInt8 : int
    {
        ENUM_FORCE_UINT8_DAY_UNKNOWN = 0,
        ENUM_FORCE_UINT8_DAY_MONDAY = 1,
        ENUM_FORCE_UINT8_DAY_TUESDAY = 2,
        ENUM_FORCE_UINT8_DAY_WEDNESDAY = 3,
        ENUM_FORCE_UINT8_DAY_THURSDAY = 4,
        ENUM_FORCE_UINT8_DAY_FRIDAY = 5,
        _ENUM_FORCE_UINT8 = 255
    }

    [CNode(Kind = "TypeAlias")]
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
    public struct TypeDef_FunctionPointer_ReturnVoid_ArgsVoid
    {
        [FieldOffset(0)]
        public FnPtr_Void Data;

        public static implicit operator FnPtr_Void(TypeDef_FunctionPointer_ReturnVoid_ArgsVoid data) => data.Data;
        public static implicit operator TypeDef_FunctionPointer_ReturnVoid_ArgsVoid(FnPtr_Void data) => new() { Data = data };
    }

    #endregion

    #region Runtime

    public static class Runtime
    {
        [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
        public sealed class CConstAttribute : Attribute
        {
            // marker
        }

        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Enum | AttributeTargets.Field)]
        public sealed class CNodeAttribute : Attribute
        {
            public string Kind { get; set; } = string.Empty;
        }

        /// <summary>
        ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
        ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
        ///     <c>true</c>.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly struct CBool : IEquatable<CBool>
        {
            private readonly byte _value;

            private CBool(bool value)
            {
                _value = Convert.ToByte(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="CBool" />.</returns>
            public static implicit operator CBool(bool value)
            {
                return FromBoolean(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="CBool" />.</returns>
            public static CBool FromBoolean(bool value)
            {
                return new CBool(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="bool" />.</returns>
            public static implicit operator bool(CBool value)
            {
                return ToBoolean(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="bool" />.</returns>
            public static bool ToBoolean(CBool value)
            {
                return Convert.ToBoolean(value._value);
            }

            /// <inheritdoc />
            public override string ToString()
            {
                return ToBoolean(this).ToString();
            }

            /// <inheritdoc />
            public override bool Equals(object? obj)
            {
                return obj is CBool b && Equals(b);
            }

            /// <inheritdoc />
            public bool Equals(CBool other)
            {
                return _value == other._value;
            }

            /// <inheritdoc />
            public override int GetHashCode()
            {
                return _value.GetHashCode();
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CBool" /> to compare.</param>
            /// <param name="right">The second <see cref="CBool" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool operator ==(CBool left, CBool right)
            {
                return left._value == right._value;
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
            /// </summary>
            /// <param name="left">The first <see cref="CBool" /> to compare.</param>
            /// <param name="right">The second <see cref="CBool" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
            public static bool operator !=(CBool left, CBool right)
            {
                return !(left == right);
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CBool" /> to compare.</param>
            /// <param name="right">The second <see cref="CBool" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool Equals(CBool left, CBool right)
            {
                return left._value == right._value;
            }
        }

        /// <summary>
        ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
        ///     an unmanaged context.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
        {
            private readonly byte _value;

            private CChar(byte value)
            {
                _value = Convert.ToByte(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="CChar" />.</returns>
            public static implicit operator CChar(byte value)
            {
                return FromByte(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="CChar" />.</returns>
            public static CChar FromByte(byte value)
            {
                return new CChar(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="byte" />.</returns>
            public static implicit operator byte(CChar value)
            {
                return ToByte(value);
            }

            /// <summary>
            ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
            /// </summary>
            /// <param name="value">The value.</param>
            /// <returns>A <see cref="byte" />.</returns>
            public static byte ToByte(CChar value)
            {
                return value._value;
            }

            /// <inheritdoc />
            public override string ToString()
            {
                return _value.ToString(CultureInfo.InvariantCulture);
            }

            /// <inheritdoc />
            public override bool Equals(object? obj)
            {
                return obj is CChar value && Equals(value);
            }

            /// <inheritdoc />
            public bool Equals(byte other)
            {
                return _value == other;
            }

            /// <inheritdoc />
            public bool Equals(CChar other)
            {
                return _value == other._value;
            }

            /// <inheritdoc />
            public override int GetHashCode()
            {
                return _value.GetHashCode();
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CChar" /> to compare.</param>
            /// <param name="right">The second <see cref="CChar" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool operator ==(CChar left, CChar right)
            {
                return left._value == right._value;
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
            /// </summary>
            /// <param name="left">The first <see cref="CChar" /> to compare.</param>
            /// <param name="right">The second <see cref="CChar" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
            public static bool operator !=(CChar left, CChar right)
            {
                return !(left == right);
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CChar" /> to compare.</param>
            /// <param name="right">The second <see cref="CChar" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool Equals(CChar left, CChar right)
            {
                return left._value == right._value;
            }
        }

        /// <summary>
        ///     A pointer value type of bytes that represent a string; the C type `char*`.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly unsafe struct CString : IEquatable<CString>
        {
            internal readonly nint _pointer;

            /// <summary>
            ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
            /// </summary>
            public bool IsNull => _pointer == 0;

            /// <summary>
            ///     Initializes a new instance of the <see cref="CString" /> struct.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            public CString(byte* value)
            {
                _pointer = (nint)value;
            }

            /// <summary>
            ///     Initializes a new instance of the <see cref="CString" /> struct.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            public CString(nint value)
            {
                _pointer = value;
            }

            /// <summary>
            ///     Initializes a new instance of the <see cref="CString" /> struct.
            /// </summary>
            /// <param name="s">The string value.</param>
            public CString(string s)
            {
                _pointer = FromString(s)._pointer;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CString" />.
            /// </returns>
            public static explicit operator CString(nint value)
            {
                return FromIntPtr(value);
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CString" />.
            /// </returns>
            public static CString FromIntPtr(nint value)
            {
                return new CString(value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CString" />.
            /// </returns>
            public static implicit operator CString(byte* value)
            {
                return From(value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CString" />.
            /// </returns>
            public static CString From(byte* value)
            {
                return new CString((nint)value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
            /// </summary>
            /// <param name="value">The pointer.</param>
            /// <returns>
            ///     The resulting <see cref="IntPtr" />.
            /// </returns>
            public static implicit operator nint(CString value)
            {
                return value._pointer;
            }

            /// <summary>
            ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
            /// </summary>
            /// <param name="value">The pointer.</param>
            /// <returns>
            ///     The resulting <see cref="IntPtr" />.
            /// </returns>
            public static nint ToIntPtr(CString value)
            {
                return value._pointer;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="CString" /> to a <see cref="string" />.
            /// </summary>
            /// <param name="value">The <see cref="CString" />.</param>
            /// <returns>
            ///     The resulting <see cref="string" />.
            /// </returns>
            public static explicit operator string(CString value)
            {
                return ToString(value);
            }

            /// <summary>
            ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
            ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying.
            /// </summary>
            /// <param name="value">A pointer to the C string.</param>
            /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
            public static string ToString(CString value)
            {
                if (value.IsNull)
                {
                    return string.Empty;
                }

                // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                var result = Marshal.PtrToStringAnsi(value._pointer);

                if (string.IsNullOrEmpty(result))
                {
                    return string.Empty;
                }

                return result;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="string" /> to a <see cref="CString" />.
            /// </summary>
            /// <param name="s">The <see cref="string" />.</param>
            /// <returns>
            ///     The resulting <see cref="CString" />.
            /// </returns>
            public static explicit operator CString(string s)
            {
                return FromString(s);
            }

            /// <summary>
            ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
            ///     <c>0x0</c>) by allocating and copying.
            /// </summary>
            /// <param name="str">The <see cref="string" />.</param>
            /// <returns>A C string pointer.</returns>
            public static CString FromString(string str)
            {
                var pointer = Marshal.StringToHGlobalAnsi(str);
                return new CString(pointer);
            }

            /// <inheritdoc />
            public override string ToString()
            {
                return ToString(this);
            }

            /// <inheritdoc />
            public override bool Equals(object? obj)
            {
                return obj is CString value && Equals(value);
            }

            /// <inheritdoc />
            public bool Equals(CString other)
            {
                return _pointer == other._pointer;
            }

            /// <inheritdoc />
            public override int GetHashCode()
            {
                return _pointer.GetHashCode();
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CString" /> to compare.</param>
            /// <param name="right">The second <see cref="CString" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool operator ==(CString left, CString right)
            {
                return left._pointer == right._pointer;
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
            /// </summary>
            /// <param name="left">The first <see cref="CString" /> to compare.</param>
            /// <param name="right">The second <see cref="CString" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
            public static bool operator !=(CString left, CString right)
            {
                return !(left == right);
            }
        }

        /// <summary>
        ///     Utility methods for interoperability with C style strings in C#.
        /// </summary>
        public static unsafe class CStrings
        {
            /// <summary>
            ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
            ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
            /// </summary>
            /// <remarks>
            ///     <para>Calls <see cref="CString" />.</para>
            /// </remarks>
            /// <param name="values">The strings.</param>
            /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
            public static CString* CStringArray(ReadOnlySpan<string> values)
            {
                var pointerSize = IntPtr.Size;
                var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                for (var i = 0; i < values.Length; ++i)
                {
                    var @string = values[i];
                    var cString = CString.FromString(@string);
                    result[i] = cString;
                }

                return result;
            }

            /// <summary>
            ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
            ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
            /// </summary>
            /// <remarks>
            ///     <para>Calls <see cref="CString" />.</para>
            /// </remarks>
            /// <param name="values">The strings.</param>
            /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
            public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
            {
                var pointerSize = IntPtr.Size;
                var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                for (var i = 0; i < values.Length; ++i)
                {
                    var @string = values[i];
                    var cString = CStringWide.FromString(@string);
                    result[i] = cString;
                }

                return result;
            }
        }

        /// <summary>
        ///     A pointer value type that represents a wide string; C type `wchar_t*`.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly unsafe struct CStringWide : IEquatable<CStringWide>
        {
            internal readonly nint _pointer;

            /// <summary>
            ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
            /// </summary>
            public bool IsNull => _pointer == 0;

            /// <summary>
            ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            public CStringWide(byte* value)
            {
                _pointer = (nint)value;
            }

            /// <summary>
            ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            public CStringWide(nint value)
            {
                _pointer = value;
            }

            /// <summary>
            ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
            /// </summary>
            /// <param name="s">The string value.</param>
            public CStringWide(string s)
            {
                _pointer = FromString(s)._pointer;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CStringWide" />.
            /// </returns>
            public static explicit operator CStringWide(nint value)
            {
                return FromIntPtr(value);
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CStringWide" />.
            /// </returns>
            public static CStringWide FromIntPtr(nint value)
            {
                return new CStringWide(value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CStringWide" />.
            /// </returns>
            public static implicit operator CStringWide(byte* value)
            {
                return From(value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
            /// </summary>
            /// <param name="value">The pointer value.</param>
            /// <returns>
            ///     The resulting <see cref="CStringWide" />.
            /// </returns>
            public static CStringWide From(byte* value)
            {
                return new CStringWide((nint)value);
            }

            /// <summary>
            ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
            /// </summary>
            /// <param name="value">The pointer.</param>
            /// <returns>
            ///     The resulting <see cref="IntPtr" />.
            /// </returns>
            public static implicit operator nint(CStringWide value)
            {
                return value._pointer;
            }

            /// <summary>
            ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
            /// </summary>
            /// <param name="value">The pointer.</param>
            /// <returns>
            ///     The resulting <see cref="IntPtr" />.
            /// </returns>
            public static nint ToIntPtr(CStringWide value)
            {
                return value._pointer;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
            /// </summary>
            /// <param name="value">The <see cref="CStringWide" />.</param>
            /// <returns>
            ///     The resulting <see cref="string" />.
            /// </returns>
            public static explicit operator string(CStringWide value)
            {
                return ToString(value);
            }

            /// <summary>
            ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
            ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying.
            /// </summary>
            /// <param name="value">A pointer to the C string.</param>
            /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
            public static string ToString(CStringWide value)
            {
                if (value.IsNull)
                {
                    return string.Empty;
                }

                // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                var result = Marshal.PtrToStringUni(value._pointer);

                if (string.IsNullOrEmpty(result))
                {
                    return string.Empty;
                }

                return result;
            }

            /// <summary>
            ///     Performs an explicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
            /// </summary>
            /// <param name="s">The <see cref="string" />.</param>
            /// <returns>
            ///     The resulting <see cref="CStringWide" />.
            /// </returns>
            public static explicit operator CStringWide(string s)
            {
                return FromString(s);
            }

            /// <summary>
            ///     Converts a C string pointer (one dimensional byte array terminated by a
            ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
            /// </summary>
            /// <param name="str">The <see cref="string" />.</param>
            /// <returns>A C string pointer.</returns>
            public static CStringWide FromString(string str)
            {
                var pointer = Marshal.StringToHGlobalUni(str);
                return new CStringWide(pointer);
            }

            /// <inheritdoc />
            public override string ToString()
            {
                return ToString(this);
            }

            /// <inheritdoc />
            public override bool Equals(object? obj)
            {
                return obj is CStringWide value && Equals(value);
            }

            /// <inheritdoc />
            public bool Equals(CStringWide other)
            {
                return _pointer == other._pointer;
            }

            /// <inheritdoc />
            public override int GetHashCode()
            {
                return _pointer.GetHashCode();
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
            /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool operator ==(CStringWide left, CStringWide right)
            {
                return left._pointer == right._pointer;
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
            /// </summary>
            /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
            /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
            public static bool operator !=(CStringWide left, CStringWide right)
            {
                return !(left == right);
            }

            /// <summary>
            ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
            /// </summary>
            /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
            /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
            /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
            public static bool Equals(CStringWide left, CStringWide right)
            {
                return left._pointer == right._pointer;
            }
        }
    }

    #endregion
}